import json
from typing import Dict, List, Optional

class Cell:
    def __init__(self, id: str, code: str, parent_id: Optional[str] = None):
        self.id = id
        self.code = code
        self.parent_id = parent_id

def export_to_python(cells: List[Dict]) -> str:
    """
    Export the notebook cells to a runnable Python file.
    Preserves the execution order and dependencies between cells.
    
    Args:
        cells: List of cell dictionaries containing id, code, and parentId
        
    Returns:
        str: Complete Python script that can be executed
    """
    # Convert cells to Cell objects
    cell_objects = [Cell(c["id"], c["code"], c.get("parentId")) for c in cells]
    
    # Create a mapping of cell IDs to their objects for easy lookup
    cell_map = {cell.id: cell for cell in cell_objects}
    
    # Helper function to get execution path from root to a cell
    def get_execution_path(cell_id: str) -> List[Cell]:
        path = []
        current_id = cell_id
        while current_id:
            current_cell = cell_map[current_id]
            path.insert(0, current_cell)
            current_id = current_cell.parent_id
        return path

    # Get all leaf cells (cells with no children)
    child_ids = {c.parent_id for c in cell_objects if c.parent_id}
    leaf_cells = [c for c in cell_objects if c.id not in child_ids]
    
    # Get all unique execution paths
    all_paths = []
    for leaf in leaf_cells:
        path = get_execution_path(leaf.id)
        if path not in all_paths:
            all_paths.append(path)
    
    # Generate the Python script
    script_parts = [
        "# Generated by BranchPad\n",
        "# This script contains all execution paths from the notebook\n\n",
        "import sys\n",
        "from typing import Dict, Any\n\n",
        "# Function to execute a cell and maintain its namespace\n",
        "def execute_cell(code: str, namespace: Dict[str, Any]) -> Dict[str, Any]:\n",
        "    try:\n",
        "        exec(code, namespace)\n",
        "        return namespace\n",
        "    except Exception as e:\n",
        "        print(f'Error executing cell: {str(e)}', file=sys.stderr)\n",
        "        raise\n\n"
    ]
    
    # Add each execution path as a function
    for i, path in enumerate(all_paths):
        path_name = f"execution_path_{i + 1}"
        path_desc = " -> ".join(c.id for c in path)
        
        script_parts.extend([
            f"def {path_name}():\n",
            f"    # Execution path: {path_desc}\n",
            "    namespace = {}\n"
        ])
        
        # Add each cell's code in the path
        for cell in path:
            script_parts.extend([
                f"    # Cell {cell.id}\n",
                "    try:\n",
                f"        {cell.code.strip().replace('\n', '\n        ')}\n",
                "    except Exception as e:\n",
                "        print(f'Error in cell {cell.id}: {str(e)}', file=sys.stderr)\n",
                "        raise\n\n"
            ])
        
        script_parts.append("\n")
    
    # Add main section to run all paths
    script_parts.extend([
        "if __name__ == '__main__':\n",
        "    # Execute all paths\n"
    ])
    
    for i in range(len(all_paths)):
        path_name = f"execution_path_{i + 1}"
        script_parts.append(f"    print('\\nExecuting {path_name}...')\n")
        script_parts.append(f"    {path_name}()\n")
    
    return "".join(script_parts)

def export_environment() -> str:
    """
    Export the current Python environment information.
    Returns a requirements.txt compatible string.
    """
    import pkg_resources
    
    packages = [
        f"{dist.key}=={dist.version}"
        for dist in pkg_resources.working_set
    ]
    return "\n".join(sorted(packages)) 